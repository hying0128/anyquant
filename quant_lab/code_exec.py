#-*- coding:utf-8 -*-__author__ = 'cheng'import os, refrom collections import OrderedDictimport functoolsimport pandas as pdfrom datetime import datetimeimport timeimport zipline.utils.factory as factoryfrom zipline.algorithm import TradingAlgorithmfrom zipline.finance import tradingimport pytzfrom six import exec_import numpy as npfrom django.db import connectionfrom quant_base.settings import STOCK_DATA_DIR, CODE_DIR, CODE_INS_DIRfrom models import Stockfrom quant_lab_util import forme_date_tsfrom global_util.quant_zipline import load_custom_benchmark_datadef execute_code(code, **kwargs):    """    执行代码    需要解析得到对应的股票基金代号并    查找对应的文件读取    :param code:    :param kwargs:    :return: {'status': 'ok/error', data: {}}    annualized_return 年化收益率    benchmark_annualized_return 基准年化收益率    alpha 阿尔法    beta 贝塔    sharpe 夏普比率    volatility 收益波动率    information 信息比率    max_drawdown 最大回撤    cumulative_return: {'': 1} 策略累计收益率    benchmark_ cumulative_return {'': 1} 基准累计收益率    """    if not _check_code(code):        return {'status': 'error', 'data': u'代码中包含禁止的调用库'}    dict_data = OrderedDict()    #需要代码保存再读取，防止出现格式编码问题    #如果已经保存过，直接读取    if not kwargs.get('code_ins_path'):        code_ins_path = os.path.join(CODE_INS_DIR, 'tmp',                                     'algo_' + datetime.now().strftime("%Y%m%d%H%M%S%s") + '.py')        with open(code_ins_path, 'wb') as code_file:            code_file.write(code.encode('utf8'))    else:        code_ins_path = kwargs.get('code_ins_path')    with open(code_ins_path, 'rb') as read_code_file:        r_code = ''.join(read_code_file.readlines())    #测试用，需要匹配获取    stocks = _extract_stocks(r_code)    if not stocks:        return {'status': 'error', 'data': u'未识别的股票或基金代码'}    start_date = datetime.strptime(kwargs.get('start'), "%Y-%m-%d")    end_date = datetime.strptime(kwargs.get('end'), "%Y-%m-%d")    start = pd.datetime(year=start_date.year, month=start_date.month, day=start_date.day, tzinfo=pytz.utc)    end = pd.datetime(year=end_date.year, month=end_date.month, day=end_date.day, tzinfo=pytz.utc)    #判断时间，仅提供2006年后的数据    if start < pd.datetime(year=2006, month=1, day=1, tzinfo=pytz.utc) \            or end >= pd.datetime.now(tz=pytz.utc) or start > end:        return {'status': 'error', 'data': u'时间选择有误'}    start_str = kwargs.get('start', '2013-01-01')    end_str = kwargs.get('end', '2014-01-01')    #test for se    #start_str = '2014-01-01'    #end_str = '2015-01-01'    #start = pd.datetime(2014, 1, 1, tzinfo=pytz.utc)    #end = pd.datetime(2015, 1, 1, tzinfo=pytz.utc)    data_stocks = stocks[:100]    for stock in data_stocks:        #从数据库中读取数据        '''        stock_query = str(Stock.objects.filter(code="'" + stock + "'")                          .filter(date__gte="" + start_str+ "")                          .filter(date__lte="" + end_str + "").all().query)        '''        stock_query = "select id, type, code, date, open, high, low, close, adj_price, volume" + \            " from stocks " + \            "where code='%s' and date>='%s' and date<='%s' order by date"%(stock, start_str, end_str)        data = pd.read_sql_query(stock_query, connection, index_col='date')        #data.index = data.index.tz_localize('UTC')        '''        if len(data) < 1:            return {'status': 'error', 'data': u'没有合适的数据'}        '''        if len(data) > 0:            dict_data[stock] = data    pannel = pd.Panel(dict_data)    with open('stock_data.dat', 'wb') as stock_file:        for k in dict_data.keys():            stock_file.write(str(dict_data[k]))            stock_file.write('\n')    pannel.minor_axis = ['id', 'type', 'code', 'open', 'high', 'low', 'close', 'price', 'volume']    #自定义运行环境，不需要从yahoo爬取    overload_bm_func = functools.partial(load_custom_benchmark_data, data)    with trading.TradingEnvironment(load=overload_bm_func, bm_symbol="SHA300"):        sim_params = factory.create_simulation_parameters(            start=start, end=end, capital_base=float(kwargs.get('capital_base')))        sim_params.data_frequency = 'daily'        sim_params.emission_rate = 'daily'        algo = TradingAlgorithm(script=r_code,                            sim_params=sim_params,                            namespace=kwargs.get('namespace', {}),                            capital_base=float(kwargs['capital_base']))        #try:        result = algo.run(pannel)        #except:        #    return {'status': 'error', 'data': u'ops! 数据出现了点问题'}    algo_cumulative_return = [[forme_date_ts(datetime.fromtimestamp(result.index[idx].value/1000000000)),                               d * 100] \                              for idx, d in enumerate(result['returns'])]    final_algo_cumu_return = []    cumsum = 0.0    for d in algo_cumulative_return:        cumsum += d[1]        final_algo_cumu_return.append([d[0], cumsum])    #cumulative returns    benchmark_cumulative_return, benchmark_return = _benchmark_returns(index='sh000300', start=start, end=end)    final_cumulative_return = algo_cumulative_return[-1][1]    final_benchmark_return = benchmark_cumulative_return[-1][1]    annual_return = _annualized_return(final_cumulative_return/100,                                    len(algo_cumulative_return))    benchmark_annual_return = _benchmark_annualized_return(final_benchmark_return/100,                               len(algo_cumulative_return))    #根据结果获得指标    perf = algo.perf_tracker.cumulative_risk_metrics.to_dict()    print perf    perf_data = {'annualized_return': '%.4f' % (perf.get('algorithm_period_return', 0.0)),                 'benchmark_annualized_return': '%.4f' % (perf.get('benchmark_period_return', 0.0)),                 'alpha': '%.4f' % (perf.get('alpha', 0.0)),                 'beta': '%.4f' % (perf.get('beta', 0.0)),                 'sharpe': '%.4f' % (perf.get('sharpe', 0.0)),                 'volatility': '%.4f' % (perf.get('algo_volatility', 0.0)),                 'information': '%.4f' % (perf.get('information', 0.0)),                 'max_drawdown': '%.4f' % (perf.get('max_drawdown', 0.0)),                 'cumulative_return': algo_cumulative_return,                 'benchmark_return': benchmark_cumulative_return}    return {'status': 'ok', 'data': perf_data}def _check_code(code):    """    检查是否包含非法引用的package，如os,sys等    :param code:    :return:    """    forbid_modules = ['os', 'sys', 'commands']    forbid_modules_pattern = '|'.join(map(lambda x: '(' + x + ')', forbid_modules))    pattern = "(((import)|(from))+.*[\s|,]+(" + forbid_modules_pattern + ')+)'    for line in code.split('\n'):        if re.search(pattern, line):            return False    return Truedef _extract_stocks(code):    """    从代码中提取股票或基金代码    TODO    :param code:    :return:    """    namespaces = {}    exec_(code, namespaces)    return namespaces.get('universes', [])def _annualized_return(final_cumulative_return, trading_days):    """    计算策略年化收益率    :param final_cumulative_return:    :return:    """    return (1+final_cumulative_return) ** (250.0/trading_days) -1def _benchmark_returns(index='sh000300', start=None, end=None):    """    计算股票或基金的benchmark 收益率    目前默认使用沪深指数300    :param data: 股票或基金数据    :return:    """    if start is None:        start = datetime(year=2013, month=1, day=1)    if end is None:        end = datetime.utcnow()    bench_data = _get_benchmark_data(index, start, end)    benchmark_returns = []    benchmark_cumulative_returns = []    cumsum = 0.0    for i, data in enumerate(bench_data):        if i == 0:            curr_open = bench_data[i].open            returns = (bench_data[i].close - curr_open) / curr_open        else:            pre_close = bench_data[i-1].close            returns = (data.close - pre_close) / pre_close        cumsum += returns        benchmark_cumulative_returns.append([forme_date_ts(data.date), cumsum * 100])        benchmark_returns.append(returns)    return benchmark_cumulative_returns, benchmark_returnsdef _benchmark_annualized_return(final_benchmark_return, trading_days):    """    计算基准年化收益率    :return:    """    return (1 + final_benchmark_return) ** (250.0/trading_days) - 1def _get_benchmark_data(index, start, end):    """    获取给定指数的数据    :param index:    :param start:    :param end:    :return:    """    index_data = Stock.objects.filter(code=index).filter(date__gte=start)\        .filter(date__lte=end).order_by('date')    return [d for d in index_data]def _calc_volatility(strategy_returns):    """    计算策略收益波动率    策略收益的标准差 每日收益 平均收益    :param strategy_returns:    :return:    """    mean_return = np.mean(strategy_returns)    pow_sum = sum([(d-mean_return)**2 for d in strategy_returns])    return np.sqrt(pow_sum / (len(strategy_returns) -1 ))def _calc_max_drawdown(strategy_value):    """    计算最大回撤    max(1- curValue/prevMaxValue)    :param strategy_value:    :return:    """    if not strategy_value:        return 0.0    prev_max = strategy_value[0]    max_drawdown = 0.0    for d in strategy_value:        if d > prev_max:            prev_max = d        cur = 1.0 - d * 1.0 / prev_max        max_drawdown = cur if cur > max_drawdown else max_drawdown    return '%.4f'%(max_drawdown)def _calc_beta(strategy_return, benchmark_return):    strategy_mean = np.mean(strategy_return)    benchmark_mean = np.mean(benchmark_return)    sum = 0.0    for i in xrange(len(strategy_return)):        sum += (strategy_return[i] - strategy_mean)*(benchmark_return[i] \                if len(benchmark_return) > i else benchmark_return[-1] - benchmark_mean)    cov = sum / len(strategy_return)    benchmark_var = np.var(benchmark_return)    return cov / benchmark_var